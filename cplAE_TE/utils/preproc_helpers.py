import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

import json
from cplAE_TE.utils.load_helpers import get_paths
    
def get_spc_names_v2():
    """Parse sparse pc names from .json generated by Nathan, for revised dataset in Gouwens et al. 2020. 

    Returns:
        E_name_array: np.array of object type containing names of Ephys features
    """


    path = get_paths()
    with open(path['v2_spc_names']) as f:
        new_comp_info = json.load(f)
    new_col_lookup = {}
    counter = 0
    for ci in new_comp_info:
        new_col_lookup[ci["key"]] = [str(counter + i)
                                     for i, v in enumerate(ci["indices"])]
        counter += len(ci["indices"])

    keys_ = []
    columns_ = []
    for key, value in new_col_lookup.items():
        for i, v in enumerate(value):
            keys_.append(key+'_'+str(i))
            columns_.append(v)
    keys_ = np.array(keys_)
    columns_ = np.array([int(c) for c in columns_])

    sort_ind = np.argsort(columns_)
    keys_ = keys_[sort_ind]
    columns_ = columns_[sort_ind]
    keys_ = [k.strip() for k in keys_]
    E_name_array = np.array(keys_, dtype=object)
    return E_name_array


def standardize_E(df, feature_list, z_absmax=6.0, plots=False):
    """Remove outliers and standardize columns of the (Ephys.) dataframe (either principle component scores or IPFX features)

    Args:
        df: E_pc or E_ipfx
        feature_list: list of features to standardize in the dataframe
        z_absmax: Number of standard deviations away from mean to fix values of outliers. Choose conservatively.
        plots (bool): plot distribution of values after z-scoring and outlier removal

    Returns:
        df: Dataframe with z-scored and outlier-removed values
        feature_means
    """

    feature_mean = []
    feature_std = []
    for i, feature in enumerate(feature_list):
        e = df[feature].copy()
        low = e.dropna().quantile(q=0.01)
        high = e.dropna().quantile(q=0.99)

        # ignore nans, and outliers defined by percentiles to calculate means and std
        values = e[e.between(low, high)]
        e_mean = np.mean(values)
        e_std = np.std(values)
        e = (e-e_mean)/e_std
        feature_mean.append(e_mean)
        feature_std.append(e_std)

        # set outliers to boundary
        num_set = (e.gt(z_absmax) | e.lt(-z_absmax)).sum()
        nan_ind = e.isna()
        e[e > z_absmax] = z_absmax
        e[e < -z_absmax] = -z_absmax
        e[nan_ind] = np.nan
        df[feature] = e

        if num_set > 0:
            print('{} outliers in {}'.format(num_set, feature))

        if plots:
            fig_ncols = 5
            # each figure is a single row with `fig_ncols` columns
            if i % fig_ncols == 0:
                plt.figure(figsize=(17, 3))
            plt.subplot(1, fig_ncols, i % fig_ncols+1)
            plt.hist(e[~nan_ind])
            plt.title(f'{feature:s}, \n {e.isna().sum():d}')

            if (i+1) % fig_ncols == 0:
                plt.tight_layout()
                plt.show()

    return df, feature_mean, feature_std
